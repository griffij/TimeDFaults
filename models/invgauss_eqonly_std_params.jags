# Use standard parameterisation with mu, lambda
# Number of censored observations
data {
 for (i in 1:N){
 zeros[i] = 0
 }
 C = 10000
}
model{
  for (i in 1:N){
   # Prior for lambda parameter
  zeros[i] ~ dpois(zeros.mean[i])
  zeros.mean[i] = -l[i] + C
  # Censoring
  y[i] = ifelse(isCensored[i], censorLimitVec[i], Y[i])
  # For calculating CDF
  u1[i] = pow((lambda/y[i]), 1/2)*(y[i]/mu - 1)
  u2[i] = -1*pow((lambda/y[i]), 1/2)*(y[i]/mu + 1)
  cdf[i] = pnorm(u1[i], 0, 1) + exp((2*lambda)/mu)*pnorm(u2[i], 0, 1)
  # Log-likelihood 
  l[i] = ifelse(isCensored[i],
       log(1-cdf[i]),
       0.5*(log(lambda) - log(2*3.1416) - 3*log(y[i])) -
       0.5*lambda*pow((y[i] - mu), 2)/(pow(mu, 2)*y[i])
       )
    }
    
# Lets track alpha as well
alpha = pow((mu/lambda), 1/2)
# Priors - uninformative
lambda ~ dunif(0, 40000)
#lambda ~ dnorm(15000, 1e-8)T(0,)
mu ~ dunif(0, 150000)
#throw_per_event ~ dnorm(2.5, 8)T(0,) # Estimate of throw per event from trench data
}